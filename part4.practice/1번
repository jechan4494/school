// 1번

#include <iostream>
using namespace std;
class Color {
	int red, green, blue; //
public:
	Color() { red = green = blue = 0; }
	Color(int r, int g, int b) { red = r, green = g, blue = b; }
	void setColor(int r, int g, int b) { red = r; green = g, blue = b; }
	void show() { cout << red << ' ' << green << ' ' << blue << endl; }
};

int main() {

	Color screenColor(255, 0, 0);
	Color* p; // Color 타입의 포인터 변수 p선언
	p = &screenColor; // screenColor주소를 p에 넣음 
	p->show(); // screenColor 색 출력
	Color colors[3]; // color의 일차원 배열 colors선언.
	p = colors; // p가 colors 배열을 가르키는 코드

	p->setColor(255, 0, 0); //빨강 초록 파랑 가짐
	(p+1)->setColor(0, 255, 0);
	(p + 2)->setColor(0, 0, 255);

	for (int i = 0; i < 3; i++) {
		p->show();
		p++;
	}
}

// 11번 //////////////////////////////////////////

#include <iostream> 
#include <string> 
using namespace std; 


class container {
    int size; // 재료의 크기를 나타내는 멤버 변수
public:
    // 재료를 채우는 메서드
    void fill() {
        size = 10; // 재료를 10 채운다.
    }
    // 용기에서 소비하는 메서드
    void consume() {
        size--; // 용기에서 재료의 크기를 하나 감소시킨다.
    }
    // 용기에서 재료의 크기를 반환하는 메서드
    int getSize() {
        return size; // 용기의 크기를 반환한다.
    }
};

// 커피 자판기 클래스
class CoffeeMachine {
    container tong[3]; // 커피, 물, 설탕을 담는 용기 배열

public:
    // 에스프레소 선택 메서드
    void selectEspresso();
    // 아메리카노 선택 메서드
    void selectAmericano();
    // 설탕커피 선택 메서드
    void selectSugercoffee();
    // 용기 채우는 메서드
    void fill();
    // 현재 상태 출력 메서드
    void show();
    // 자판기 작동 메서드
    void run();
};

// 에스프레소 선택 메서드 구현
void CoffeeMachine::selectEspresso() {
    tong[0].consume(); // 커피 용기에서 소비한다.
    tong[1].consume(); // 물 용기에서 소비한다.
}

// 아메리카노 선택 메서드 구현
void CoffeeMachine::selectAmericano() {
    tong[0].consume(); // 커피 용기에서 소비한다.
    tong[1].consume(); // 물 용기에서 소비한다.
    tong[1].consume(); // 물 용기에서 소비한다.
}

// 설탕커피 선택 메서드 구현
void CoffeeMachine::selectSugercoffee() {
    tong[0].consume(); // 커피 용기에서 소비한다.
    tong[1].consume(); // 물 용기에서 소비한다.
    tong[1].consume(); // 물 용기에서 소비한다.
    tong[2].consume(); // 설탕 용기에서 소비한다.
}

// 용기 채우는 메서드 구현
void CoffeeMachine::fill() {
    for (int i = 0; i < 3; i++) {
        tong[i].fill(); // 각 용기를 채운다.
    }
    show(); // 현재 상태를 출력한다.
}

// 현재 상태 출력 메서드 구현
void CoffeeMachine::show() {
    cout << "커피: " << tong[0].getSize() << " 물: " << tong[1].getSize() << " 설탕: " << tong[2].getSize() << endl; // 커피, 물, 설탕 용기의 크기를 출력한다.
}

// 자판기 작동 메서드 구현
void CoffeeMachine::run() {
    cout << "***** 커피자판기를 작동합니다. ******\n";

    while (true) {
        int menu;
        cout << "\n메뉴를 눌러주세요 (1: 에스프레소, 2: 아메리카노, 3: 설탕커피, 4: 잔량보기, 5: 채우기) >> ";
        cin >> menu; // 메뉴를 입력받는다.
        if (menu == 1) {
            if (tong[0].getSize() == 0 && tong[1].getSize() == 0)
                cout << "재료가 없습니다."; // 커피와 물이 모두 소진된 경우 메시지를 출력한다.
            else
                selectEspresso(); // 에스프레소를 선택한다.
        }
        if (menu == 2) {
            if (tong[0].getSize() == 0 && tong[1].getSize() <= 1)
                cout << "재료가 없습니다."; // 커피 또는 물이 모두 소진된 경우 메시지를 출력한다.
            else
                selectAmericano(); // 아메리카노를 선택한다.
        }
        if (menu == 3) {
            if (tong[0].getSize() == 0 && tong[1].getSize() <= 1 && tong[2].getSize() == 0)
                cout << "재료가 없습니다."; // 커피, 물, 설탕이 모두 소진된 경우 메시지를 출력한다.
            else
                selectSugercoffee(); // 설탕커피를 선택한다.
        }
        if (menu == 4) {
            show(); // 현재 상태를 출력한다.
        }
        if (menu == 5) {
            fill(); // 용기를 채운다.
        }
    }
}

// 메인 함수
int main() {
    CoffeeMachine r; // CoffeeMachine 객체 생성
    r.run(); // 자판기 작동 메서드 호출
    return 0; // 프로그램 종료
}

// 12번 //////////////////////////////////////////////

#include <iostream>
#include <string>

using namespace std;

class Circle {

	int radius;
	string name;

public:
	
	Circle();
	void setRadius(string name,int radius);
	double getArea();
	string getName();
};

class CircleManager {
	Circle* p;
	int size;
public:
	CircleManager(int size);
	~CircleManager();
	void searchByName();
	void searchByArea();

};

Circle::Circle() { };

void Circle::setRadius(string name, int radius) {
	this->name = name;
	this->radius=radius;
}
double Circle::getArea() {
	return 3.14 * radius * radius;
}
string Circle::getName() {
	return name;
}
CircleManager::CircleManager(int size) {
	p = new Circle[size];
	this->size = size;
	int radius; string name;
	for (int i = 0; i < size; i++) {
		cout << "원" << i + 1 << "의 이름과 반지름>>";
		cin >> name >> radius; p[i].setRadius(name, radius);
	}
}
CircleManager::~CircleManager() {
	delete[] p;
}
void CircleManager::searchByName() {
	string name;
	cout << "검색하고자 하는 원의 이름>>";
	cin >> name;
	for(int i=0; i<size; i++){
		if (name == p[i].getName()) {
			cout << name << "의 면적은" << p[i].getArea();
			return;
		}
	}
	cout << name << "은 찾을 수 없습니다";
}
void CircleManager::searchByArea() {
	int area;
	int count=0;

	cout << "최소 면적을 정수로 입력하세요 : ";
	cin >> area;
	cout << area << "보다 큰 원을 검색합니다.";
	for (int i = 0; i < size; i++) {
		if (area < p[i].getArea()) {
			cout << p[i].getName() << "의 면적은" << p[i].getArea() << ",";
			count++;
		}
	}
	if (count == 0) {
		cout << "area보다 큰 원은 없습니다." << endl;
	}
}

int main() {

	CircleManager* pM;
	int size;
	cout << "원의 개수를 입력하세요:";
	cin >> size;
	if (size <= 0) {
		cout << "양수를 입력하세요.";
		return 0;
	}

	pM = new CircleManager(size);
	pM->searchByArea();
	pM->searchByName();

	delete pM;
}
